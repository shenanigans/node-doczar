{"elemID":"component_637","date":"6/5/2020","time":"12:00am","name":"summary","pathname":"summary","pathstr":"async.retry~summary","path":[["/","async"],[".","retry"],["~","summary"]],"flags":[],"source":[["/","async"],[".","retry"]],"sourcestr":"async.retry","superClasses":[],"interfaces":[],"satisfies":[],"ctype":"spare","valtype":[],"isKwarg":false,"isMultiArg":false,"isSpare":true,"isModule":false,"isClass":false,"simpleCtype":"spare","hideCtype":false,"spares":[],"modules":[],"enums":[],"statics":[],"functions":[],"members":[],"methods":[],"localValues":[],"localFunctions":[],"arguments":[],"finalArgs":[],"finalKwargs":[],"returns":[],"throws":[],"names":[],"events":[],"signatures":[],"propertySymbols":[],"memberSymbols":[],"returnsSymbols":[],"hasChildren":true,"isTotallyEmpty":false,"doc":[{"doc":"\n\nAttempts to get a successful response from `task` no more than `times` times\nbefore returning an error. If the task is successful, the `callback` will be\npassed the result of the successful task. If all attempts fail, the callback\nwill be passed the error and result (if any) of the final attempt.\n\nobject with `times` and `interval` or a number.\n* `times` - The number of attempts to make before giving up.  The default\n  is `5`.\n* `interval` - The time to wait between retries, in milliseconds.  The\n  default is `0`. The interval may also be specified as a function of the\n  retry count (see example).\n* If `opts` is a number, the number specifies the number of times to retry,\n  with the default interval of `0`.\n`callback(err, result)` which must be called when finished, passing `err`\n(which can be `null`) and the `result` of the function's execution, and (2)\na `results` object, containing the results of the previously executed\nfunctions (if nested inside another control flow). Invoked with\n(callback, results).\ntask has succeeded, or after the final failed attempt. It receives the `err`\nand `result` arguments of the last attempt at completing the `task`. Invoked\nwith (err, results).\n\n### Example\n```javascript\n\n// The `retry` function can be used as a stand-alone control flow by passing\n// a callback, as shown below:\n\n// try calling apiMethod 3 times\nasync.retry(3, apiMethod, function(err, result) {\n    // do something with the result\n});\n\n// try calling apiMethod 3 times, waiting 200 ms between each retry\nasync.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n    // do something with the result\n});\n\n// try calling apiMethod 10 times with exponential backoff\n// (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\nasync.retry({\n  times: 10,\n  interval: function(retryCount) {\n    return 50 * Math.pow(2, retryCount);\n  }\n}, apiMethod, function(err, result) {\n    // do something with the result\n});\n\n// try calling apiMethod the default 5 times no delay between each retry\nasync.retry(apiMethod, function(err, result) {\n    // do something with the result\n});\n\n// It can also be embedded within other control flow functions to retry\n// individual methods that are not as reliable, like this:\nasync.auto({\n    users: api.getUsers.bind(api),\n    payments: async.retry(3, api.getPayments.bind(api))\n}, function(err, results) {\n    // do something with the results\n});\n\n```\n\n","context":[]}],"breadcrumbs":[{"path":[["/","async"]],"name":"async","delimiter":"/"},{"path":[["/","async"],[".","retry"]],"name":"retry","delimiter":"."},{"path":[["/","async"],[".","retry"],["~","summary"]],"name":"summary","delimiter":"~"}],"sanitaryName":"summary_1","baseTagPath":"../../../../../../"}
