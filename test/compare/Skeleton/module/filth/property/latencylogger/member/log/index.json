{"elemID":"component_1404","date":"6/5/2020","time":"12:00am","name":"log","pathname":"log","pathstr":"filth.LatencyLogger#log","path":[["/","filth"],[".","LatencyLogger"],["#","log"]],"flags":[],"source":[["/","filth"],[".","LatencyLogger"]],"sourcestr":"filth.LatencyLogger","superClasses":[],"interfaces":[],"satisfies":[],"ctype":"member","valtype":[{"path":[[null,"Function"]],"isPointer":false,"isArray":false,"generics":[],"name":"Function","explicit":false}],"isKwarg":false,"isMultiArg":false,"isSpare":false,"isModule":false,"isClass":false,"simpleCtype":"member","hideCtype":true,"spares":[],"modules":[],"enums":[],"statics":[],"functions":[],"members":[],"methods":[],"localValues":[],"localFunctions":[],"arguments":[{"elemID":"component_1400","date":"6/5/2020","time":"12:00am","name":"name","pathname":"name","pathstr":"filth.LatencyLogger#log(name","path":[["/","filth"],[".","LatencyLogger"],["#","latency"],["(","name"]],"flags":["optional"],"source":[["/","filth"],[".","LatencyLogger"],["#","log"]],"sourcestr":"filth.LatencyLogger#log","superClasses":[],"interfaces":[],"satisfies":[],"ctype":"argument","valtype":[{"path":[[null,"String"]],"isPointer":false,"isArray":false,"generics":[],"name":"String","explicit":true}],"isKwarg":false,"isMultiArg":false,"isSpare":false,"isModule":false,"isClass":false,"simpleCtype":"argument","hideCtype":true,"spares":[],"modules":[],"enums":[],"statics":[],"functions":[],"members":[],"methods":[],"localValues":[],"localFunctions":[],"arguments":[],"finalArgs":[],"finalKwargs":[],"returns":[],"throws":[],"names":[],"events":[],"signatures":[],"propertySymbols":[],"memberSymbols":[],"returnsSymbols":[],"hasChildren":true,"isTotallyEmpty":false,"summaryDoc":[{"doc":"\n    The name under which this latency should be logged. If no name is passed, or the passed name has\n    already been used, no latency is logged but the start time of the next logged latency is still\n    updated.\n\n    Note that any latency logged as `total` will be overwritten when [getFinalLatency]\n    (#getFinalLatency) is called.\nreturns:Boolean written\n    Whether a latency value was stored. `false` when a name conflict occurs.\n","context":[["/","filth"]]}],"details":[{"doc":"\n    The name under which this latency should be logged. If no name is passed, or the passed name has\n    already been used, no latency is logged but the start time of the next logged latency is still\n    updated.\n\n    Note that any latency logged as `total` will be overwritten when [getFinalLatency]\n    (#getFinalLatency) is called.\nreturns:Boolean written\n    Whether a latency value was stored. `false` when a name conflict occurs.\n","context":[["/","filth"]]}],"isOptional":true,"hasConstructorInfo":false,"isFunction":false,"breadcrumbs":[{"path":[["/","filth"]],"name":"filth","delimiter":"/"},{"path":[["/","filth"],[".","LatencyLogger"]],"name":"LatencyLogger","delimiter":"."},{"path":[["/","filth"],[".","LatencyLogger"],["#","log"]],"name":"log","delimiter":"#"},{"path":[["/","filth"],[".","LatencyLogger"],["#","log"],["(","name"]],"name":"name","delimiter":"("}],"aliasTo":{"path":[["/","filth"],[".","LatencyLogger"],["#","latency"],["(","name"]],"pathstr":"filth.LatencyLogger#latency(name"},"sanitaryName":"name"}],"finalArgs":[],"finalKwargs":[],"returns":[{"elemID":"component_1401","date":"6/5/2020","time":"12:00am","pathname":"","pathstr":"filth.LatencyLogger#log)","path":[["/","filth"],[".","LatencyLogger"],["#","latency"],[")",""]],"flags":[],"source":[["/","filth"],[".","LatencyLogger"],["#","log"]],"sourcestr":"filth.LatencyLogger#log","superClasses":[],"interfaces":[],"satisfies":[],"ctype":"returns","valtype":[],"isKwarg":false,"isMultiArg":false,"isSpare":false,"isModule":false,"isClass":false,"simpleCtype":"returns","hideCtype":true,"spares":[],"modules":[],"enums":[],"statics":[],"functions":[],"members":[],"methods":[],"localValues":[],"localFunctions":[],"arguments":[],"finalArgs":[],"finalKwargs":[],"returns":[],"throws":[],"names":[],"events":[],"signatures":[],"propertySymbols":[],"memberSymbols":[],"returnsSymbols":[],"hasChildren":false,"isTotallyEmpty":true,"hasConstructorInfo":false,"isFunction":false,"breadcrumbs":[{"path":[["/","filth"]],"name":"filth","delimiter":"/"},{"path":[["/","filth"],[".","LatencyLogger"]],"name":"LatencyLogger","delimiter":"."},{"path":[["/","filth"],[".","LatencyLogger"],["#","log"]],"name":"log","delimiter":"#"},{"path":[["/","filth"],[".","LatencyLogger"],["#","log"],[")",""]],"name":"","delimiter":")"}],"aliasTo":{"path":[["/","filth"],[".","LatencyLogger"],["#","latency"],[")",""]],"pathstr":"filth.LatencyLogger#latency)"},"sanitaryName":"~0"}],"throws":[],"names":[],"events":[],"signatures":[],"propertySymbols":[],"memberSymbols":[],"returnsSymbols":[],"hasChildren":true,"isTotallyEmpty":false,"sourceFile":"main.js","sourceLine":650,"summaryDoc":[{"doc":"\nLog a latency number in integer microseconds relative to the last latency logged. Calling with\nno `name` argument will reset the start time for the next logged latency. Multiple calls with\nthe same `name` will be added together to produce a total latency for the name.","context":[["/","filth"]]}],"details":[{"doc":"\nLog a latency number in integer microseconds relative to the last latency logged. Calling with\nno `name` argument will reset the start time for the next logged latency. Multiple calls with\nthe same `name` will be added together to produce a total latency for the name.","context":[["/","filth"]]}],"isFunction":true,"hasConstructorInfo":false,"breadcrumbs":[{"path":[["/","filth"]],"name":"filth","delimiter":"/"},{"path":[["/","filth"],[".","LatencyLogger"]],"name":"LatencyLogger","delimiter":"."},{"path":[["/","filth"],[".","LatencyLogger"],["#","log"]],"name":"log","delimiter":"#"}],"sanitaryName":"log","baseTagPath":"../../../../../../"}
