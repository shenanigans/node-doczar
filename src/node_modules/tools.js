
var filth = require ('filth');

/* An Array of String types identifiable to the parser as builtin literals. */
var TYPES         = exports.TYPES           = global.TYPES          = Symbol ("types");
/* An Array of Nodes whose values have been written into this Node */
var DEREF         = exports.DEREF           = global.DEREF          = Symbol ("dereference");
/* An Array of Nodes which have been used to instantiate this Node */
var INSTANCE      = exports.INSTANCE        = global.INSTANCE       = Symbol ("instance");
var ROOT          = exports.ROOT            = global.ROOT           = Symbol ("root");
var MODULE        = exports.MODULE          = global.MODULE         = Symbol ("module");
/* An Object of Nodes that are static children to this Node */
var PROPS         = exports.PROPS           = global.PROPS          = Symbol ("properties");
/* An Object of Nodes that are instance members to this Node */
var MEMBERS       = exports.MEMBERS         = global.MEMBERS        = Symbol ("members");
/* An Array of Nodes that are passed as function arguments to this Node */
var ARGUMENTS     = exports.ARGUMENTS       = global.ARGUMENTS      = Symbol ("arguments");
/* A Node representing this Node's return value(s) */
var RETURNS       = exports.RETURNS         = global.RETURNS        = Symbol ("returns");
/* Indicates that a Node is stored under ARGUMENTS or RETURNS */
var TRANSIENT     = exports.TRANSIENT       = global.TRANSIENT      = Symbol ("transient");
/*
    An Array of argument signatures used to process call expressions. Used to prevent duplicate
    call expression processing.
*/
var SIGNATURES    = exports.SIGNATURES      = global.SIGNATURES     = Symbol ("signatures");
/* Indicates that Components should not be generated for any children of this Node */
var BLIND         = exports.BLIND           = global.BLIND          = Symbol ("blind");
/* A single Node representing all throwable exception types */
var THROWS        = exports.THROWS          = global.THROWS         = Symbol ("throws");
var SUPER         = exports.SUPER           = global.SUPER          = Symbol ("super");
/*
    A boolean flag indicating that types should not be written to a name by assignment expressions.
    Used to prevent changes in scoped names, such as overwritten arguments, from propagating to
    values stored on those names.
 */
var NO_SET        = exports.NO_SET          = global.NO_SET         = Symbol ("noSet");
/*
    A boolean flag indicating that a Node is present for simulation purposes only and does not need
    to be documented. Used with standard environment roots.
*/
var SILENT        = exports.SILENT          = global.SILENT         = Symbol ("silent");
/* Stores the inner AST of a callable. */
var BODY          = exports.BODY            = global.BODY           = Symbol ("body");
/*
    An Array of callbacks which enclose function signature simulations. Used to defer simulations
    until BODY is found.
*/
var WAITING_CALLS = exports.WAITING_CALLS   = global.WAITING_CALLS  = Symbol ("waitingCalls");
/* Points to the implied object context of a callable. */
var THIS          = exports.THIS            = global.THIS           = Symbol ("this");
/* The full path of the document where this Node was first defined */
var DOC           = exports.DOC             = global.DOC            = Symbol ("document");
/* The full path of the entry file for the root context of this Node */
var REFERER       = exports.REFERER         = global.REFERER        = Symbol ("referer");
/* The line number of a line of code that first created this Node */
var LINE          = exports.LINE            = global.LINE           = Symbol ("line");
/* A String of documentation attached to this Node. */
var DOCSTR        = exports.DOCSTR          = global.DOCSTR         = Symbol ("documentString");
/* When a @module tag overrides the file scope, the override path is stored on each affected Node */
var OVERRIDE      = exports.OVERRIDE        = global.OVERRIDE       = Symbol ("overrideRoot");
/*
    An Object of manually-configured path information that will override the path assigned to
    Components generated from this Node.
*/
var MOUNT         = exports.MOUNT           = global.MOUNT          = Symbol ("mount");
var PARENT        = exports.PARENT          = global.PARENT         = Symbol ("parent");
var IS_COL        = exports.IS_COL          = global.IS_COL         = Symbol ("isCollection");
var NAME          = exports.NAME            = global.NAME           = Symbol ("name");
var PATH          = exports.PATH            = global.PATH           = Symbol ("path");
var HEAD          = exports.HEAD            = global.HEAD           = Symbol ("head");
var TAIL          = exports.TAIL            = global.TAIL           = Symbol ("tail");
var CTYPE         = exports.CTYPE           = global.CTYPE          = Symbol ("ctype");
var FINALTYPES    = exports.FINALTYPES      = global.FINALTYPES     = Symbol ("finaltypes");
var LOCALPATH     = exports.LOCALPATH       = global.LOCALPATH      = Symbol ("localpath");
var SCOPE         = exports.SCOPE           = global.SCOPE          = Symbol ("scope");
var FORCE         = exports.FORCE           = global.FORCE          = Symbol ("force");
var ALIAS         = exports.ALIAS           = global.ALIAS          = Symbol ("alias");
var LOCAL_NAME    = exports.LOCAL_NAME      = global.LOCAL_NAME     = Symbol ("localName");
var EXPORTS       = exports.EXPORTS         = global.EXPORTS        = Symbol ("exports");
/* Stores a closure used to rebase a function as a new method. */
var REBASE        = exports.REBASE          = global.REBASE         = Symbol ("rebase");
/*
    An Array of manually-configured Modifiers that should be applied to the Component generated for
    this Node.
*/
var MODS          = exports.MODS            = global.MODS           = Symbol ("modifiers");
var EXTRAS        = exports.EXTRAS          = global.EXTRAS         = Symbol ("extras");

exports.newNode = function (seed) {
    var node = Object.create (null);
    if (seed) {
        for (var key in seed)
            node[key] = seed[key];
        var syms = Object.getOwnPropertySymbols (seed);
        for (var i=0,j=syms.length; i<j; i++)
            node[syms[i]] = seed[syms[i]];
        return node;
    }
    node[TYPES] = [];
    node[DEREF] = [];
    return node;
}

exports.newCollection = function (seed) {
    var node = new filth.SafeMap (seed);
    node[IS_COL] = true;
    if (!node[TYPES])
        node[TYPES] = [];
    if (!node[DEREF])
        node[DEREF] = [];
    return node;
};

exports.pathPlus = function (path, frag) {
    var newPath = path.concat();
    newPath.push (frag);
    return newPath;
};

exports.pathStr = function (type) {
    var finalStr = type.map (function (step) {
        if (step.length === 2)
            return step.join ('');
        return step[0] + '[' + step[1] + ']';
    }).join ('')
    return type[0] && type[0][0] ? finalStr.slice (1) : finalStr;
};

exports.replaceElements = function (target, source) {
    target.splice (0, target.length);
    target.push.apply (target, source);
};

exports.pathsEqual = function (able, baker) {
    if (!able || !baker || able.length !== baker.length)
        return false;
    for (var i=0,j=able.length; i<j; i++) {
        var aI = able[i];
        var bI = baker[i];
        if (aI[0] !== bI[0] || aI[1] !== bI[1])
            return false;
        if (( aI[2] && !bI[2] ) || ( bI[2] && !aI[2] ))
            return false;
        // we can assume symbol paths are equal since their string representations are equal
    }
    return true;
};
