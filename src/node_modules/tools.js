
var filth = require ('filth');

/* An Array of String types identifiable to the parser as builtin literals. */
var TYPES         = exports.TYPES           = global.TYPES          = Symbol ("types");

/* An Array of Nodes whose values have been written into this Node */
var DEREF         = exports.DEREF           = global.DEREF          = Symbol ("dereference");

/* An Array of Nodes which have been used to instantiate this Node */
var INSTANCE      = exports.INSTANCE        = global.INSTANCE       = Symbol ("instance");

var ROOT          = exports.ROOT            = global.ROOT           = Symbol ("root");

var MODULE        = exports.MODULE          = global.MODULE         = Symbol ("module");

/* An Object of Nodes that are static children to this Node */
var PROPS         = exports.PROPS           = global.PROPS          = Symbol ("properties");

/* An Object of Nodes that are instance members to this Node */
var MEMBERS       = exports.MEMBERS         = global.MEMBERS        = Symbol ("members");

/* An Array of Nodes that are passed as function arguments to this Node */
var ARGUMENTS     = exports.ARGUMENTS       = global.ARGUMENTS      = Symbol ("arguments");

/* A Node representing this Node's return value(s) */
var RETURNS       = exports.RETURNS         = global.RETURNS        = Symbol ("returns");

/* Indicates that a Node is stored under ARGUMENTS or RETURNS */
var TRANSIENT     = exports.TRANSIENT       = global.TRANSIENT      = Symbol ("transient");

/*
    An Array of argument signatures used to process call expressions. Used to prevent duplicate
    call expression processing.
*/
var SIGNATURES    = exports.SIGNATURES      = global.SIGNATURES     = Symbol ("signatures");

/* Indicates that Components should not be generated for any children of this Node */
var BLIND         = exports.BLIND           = global.BLIND          = Symbol ("blind");

/* A single Node representing all throwable exception types */
var THROWS        = exports.THROWS          = global.THROWS         = Symbol ("throws");

var SUPER         = exports.SUPER           = global.SUPER          = Symbol ("super");

/*
    A boolean flag indicating that types should not be written to a name by assignment expressions.
    Used to prevent changes in scoped names, such as overwritten arguments, from propagating to
    values stored on those names.
 */
var NO_SET        = exports.NO_SET          = global.NO_SET         = Symbol ("noSet");

/*
    A boolean flag indicating that a Node is present for simulation purposes only and does not need
    to be documented. Used with standard environment roots.
*/
var SILENT        = exports.SILENT          = global.SILENT         = Symbol ("silent");

/* Stores the inner AST of a callable. */
var BODY          = exports.BODY            = global.BODY           = Symbol ("body");

/*
    An Array of callbacks which enclose function signature simulations. Used to defer simulations
    until BODY is found.
*/
var WAITING_CALLS = exports.WAITING_CALLS   = global.WAITING_CALLS  = Symbol ("waitingCalls");

/* Points to the implied object context of a callable. */
var THIS          = exports.THIS            = global.THIS           = Symbol ("this");

/* The full path of the document where this Node was first defined */
var DOC           = exports.DOC             = global.DOC            = Symbol ("document");

/* The full path of the entry file for the root context of this Node */
var REFERER       = exports.REFERER         = global.REFERER        = Symbol ("referer");

/* The line number of a line of code that first created this Node */
var LINE          = exports.LINE            = global.LINE           = Symbol ("line");

/* A String of documentation attached to this Node. */
var DOCSTR        = exports.DOCSTR          = global.DOCSTR         = Symbol ("documentString");

/* When a @module tag overrides the file scope, the override path is stored on each affected Node */
var OVERRIDE      = exports.OVERRIDE        = global.OVERRIDE       = Symbol ("overrideRoot");

/*
    An Object of manually-configured path information that will override the path assigned to
    Components generated from this Node.
*/
var MOUNT         = exports.MOUNT           = global.MOUNT          = Symbol ("mount");

var PARENT        = exports.PARENT          = global.PARENT         = Symbol ("parent");

var IS_COL        = exports.IS_COL          = global.IS_COL         = Symbol ("isCollection");

var NAME          = exports.NAME            = global.NAME           = Symbol ("name");

var PATH          = exports.PATH            = global.PATH           = Symbol ("path");

var HEAD          = exports.HEAD            = global.HEAD           = Symbol ("head");

var TAIL          = exports.TAIL            = global.TAIL           = Symbol ("tail");

var CTYPE         = exports.CTYPE           = global.CTYPE          = Symbol ("ctype");

var FINALTYPES    = exports.FINALTYPES      = global.FINALTYPES     = Symbol ("finaltypes");

var LOCALPATH     = exports.LOCALPATH       = global.LOCALPATH      = Symbol ("localpath");

var SCOPE         = exports.SCOPE           = global.SCOPE          = Symbol ("scope");

var FORCE         = exports.FORCE           = global.FORCE          = Symbol ("force");

var ALIAS         = exports.ALIAS           = global.ALIAS          = Symbol ("alias");

var LOCAL_NAME    = exports.LOCAL_NAME      = global.LOCAL_NAME     = Symbol ("localName");

var EXPORTS       = exports.EXPORTS         = global.EXPORTS        = Symbol ("exports");

/* Stores a closure used to rebase a function as a new method. */
var REBASE        = exports.REBASE          = global.REBASE         = Symbol ("rebase");

/*
    An Array of Nodes which are not mounted in the visible scope tree but which nevertheless may
    have side effects and should be preprocessed.
*/
var ORPHANS       = exports.ORPHANS         = global.ORPHANS        = Symbol ("orphans");

/* Indicates that no further props or methods may be added during the preprocessing stage. */
var LOCKED        = exports.LOCKED          = global.LOCKED         = Symbol ("locked");

/*
    An Array of manually-configured Modifiers that should be applied to the Component generated for
    this Node.
*/
var MODS          = exports.MODS            = global.MODS           = Symbol ("modifiers");

var EXTRAS        = exports.EXTRAS          = global.EXTRAS         = Symbol ("extras");

/*
    A Map of targets to the Number of the round on which this Level was last dereferenced onto the
    target. Used to prevent redundant processing while pre-diving DEREF.
*/
var ROUND         = exports.ROUND           = global.ROUND          = Symbol ("round");

/*
    Identifies special processing which should occur if the given Node is the callNode in a function
    call simulation.
*/
var SPECIAL       = exports.SPECIAL         = global.SPECIAL        = Symbol ("special");

exports.newNode = function (seed) {
    var node = Object.create (null);
    if (seed) {
        for (var key in seed)
            node[key] = seed[key];
        var syms = Object.getOwnPropertySymbols (seed);
        for (var i=0,j=syms.length; i<j; i++)
            node[syms[i]] = seed[syms[i]];
        return node;
    }
    node[TYPES] = [];
    node[DEREF] = [];
    return node;
}

exports.newCollection = function (seed) {
    var node = new filth.SafeMap (seed);
    node[IS_COL] = true;
    if (!node[TYPES])
        node[TYPES] = [];
    if (!node[DEREF])
        node[DEREF] = [];
    return node;
};

exports.pathPlus = function (path, frag) {
    var newPath = path.concat();
    newPath.push (frag);
    return newPath;
};

exports.pathStr = function (type) {
    var finalStr = type.map (function (step) {
        if (step.length === 2)
            return step.join ('');
        return step[0] + '[' + step[1] + ']';
    }).join ('')
    return type[0] && type[0][0] ? finalStr.slice (1) : finalStr;
};

exports.replaceElements = function (target, source) {
    target.splice (0, target.length);
    target.push.apply (target, source);
};

exports.pathsEqual = function (able, baker) {
    if (!able || !baker || able.length !== baker.length)
        return false;
    for (var i=0,j=able.length; i<j; i++) {
        var aI = able[i];
        var bI = baker[i];
        if (aI[0] !== bI[0]) {
            if (i)
                return false;
            if (aI[0] && bI[0])
                return false;
        }
        if (aI[1] !== bI[1])
            return false;
        if (( aI[2] && !bI[2] ) || ( bI[2] && !aI[2] ))
            return false;
        // we can assume symbol paths are equal since their string representations are equal
    }
    return true;
};
