{"elemID":"component_1737","date":"6/5/2020","time":"12:00am","name":"ensureAsync","pathname":"ensureAsync","pathstr":"async/Utils.ensureAsync","path":[["/","async"],["/","Utils"],[".","ensureAsync"]],"flags":[],"source":[["/","async"],["/","Utils"]],"sourcestr":"async/Utils","superClasses":[],"interfaces":[],"satisfies":[],"ctype":"property","valtype":[{"path":[[null,"Function"]],"isPointer":false,"isArray":false,"generics":[],"name":"Function","explicit":false}],"isFunction":true,"isKwarg":false,"isMultiArg":false,"isSpare":false,"isModule":false,"isClass":false,"simpleCtype":"property","hideCtype":true,"spares":[],"modules":[],"enums":[],"statics":[],"functions":[],"members":[],"methods":[],"localValues":[],"localFunctions":[],"arguments":[{"elemID":"component_1733","date":"6/5/2020","time":"12:00am","name":"fn","pathname":"fn","pathstr":"async/Utils.ensureAsync(0","path":[["/","async"],["/","Utils"],[".","ensureAsync"],["(","fn"]],"flags":[],"source":[["/","async"],["/","Utils"],[".","ensureAsync"]],"sourcestr":"async/Utils.ensureAsync","superClasses":[],"interfaces":[],"satisfies":[],"ctype":"argument","valtype":[],"isFunction":false,"isKwarg":false,"isMultiArg":false,"isSpare":false,"isModule":false,"isClass":false,"simpleCtype":"argument","hideCtype":true,"spares":[],"modules":[],"enums":[],"statics":[],"functions":[],"members":[],"methods":[],"localValues":[],"localFunctions":[],"arguments":[],"finalArgs":[],"finalKwargs":[],"returns":[],"throws":[],"names":[],"events":[],"signatures":[],"propertySymbols":[],"memberSymbols":[],"returnsSymbols":[],"hasChildren":false,"isTotallyEmpty":true,"hasConstructorInfo":false,"breadcrumbs":[{"path":[["/","async"]],"name":"async","delimiter":"/"},{"path":[["/","async"],["/","Utils"]],"name":"Utils","delimiter":"/"},{"path":[["/","async"],["/","Utils"],[".","ensureAsync"]],"name":"ensureAsync","delimiter":"."},{"path":[["/","async"],["/","Utils"],[".","ensureAsync"],["(","fn"]],"name":"fn","delimiter":"("}],"sanitaryName":"fn"}],"finalArgs":[],"finalKwargs":[],"returns":[{"elemID":"component_1734","date":"6/5/2020","time":"12:00am","pathname":"","pathstr":"async/Utils.ensureAsync)0","path":[["/","async"],["/","Utils"],[".","ensureAsync"],[")",0]],"flags":[],"source":[["/","async"],["/","Utils"],[".","ensureAsync"]],"sourcestr":"async/Utils.ensureAsync","superClasses":[],"interfaces":[],"satisfies":[],"ctype":"returns","valtype":[{"path":[[null,"Function"]],"isPointer":false,"isArray":false,"generics":[],"name":"Function","explicit":false}],"isFunction":true,"isKwarg":false,"isMultiArg":false,"isSpare":false,"isModule":false,"isClass":false,"simpleCtype":"returns","hideCtype":true,"spares":[],"modules":[],"enums":[],"statics":[],"functions":[],"members":[],"methods":[],"localValues":[],"localFunctions":[],"arguments":[],"finalArgs":[],"finalKwargs":[],"returns":[],"throws":[],"names":[],"events":[],"signatures":[],"propertySymbols":[],"memberSymbols":[],"returnsSymbols":[],"hasChildren":false,"isTotallyEmpty":true,"hasConstructorInfo":false,"breadcrumbs":[{"path":[["/","async"]],"name":"async","delimiter":"/"},{"path":[["/","async"],["/","Utils"]],"name":"Utils","delimiter":"/"},{"path":[["/","async"],["/","Utils"],[".","ensureAsync"]],"name":"ensureAsync","delimiter":"."},{"path":[["/","async"],["/","Utils"],[".","ensureAsync"],[")",0]],"name":"","delimiter":")"}],"sanitaryName":"~0"}],"throws":[],"names":[],"events":[],"signatures":[],"propertySymbols":[],"memberSymbols":[],"returnsSymbols":[],"hasChildren":true,"isTotallyEmpty":false,"summaryDoc":[{"doc":"\n\nWrap an async function and ensure it calls its callback on a later tick of\nthe event loop.  If the function already calls its callback on a next tick,\nno extra deferral is added. This is useful for preventing stack overflows\n(`RangeError: Maximum call stack size exceeded`) and generally keeping\n[Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\ncontained.\n\n\n### Example\n```javascript\nsignature as the function passed in.\n\nfunction sometimesAsync(arg, callback) {\n    if (cache[arg]) {\n        return callback(null, cache[arg]); // this would be synchronous!!\n    } else {\n        doSomeIO(arg, callback); // this IO would be asynchronous\n    }\n}\n\n// this has a risk of stack overflows if many results are cached in a row\nasync.mapSeries(args, sometimesAsync, done);\n\n// this will defer sometimesAsync's callback if necessary,\n// preventing stack overflows\nasync.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n\n```\n\n","context":[]}],"details":[{"doc":"\n\nWrap an async function and ensure it calls its callback on a later tick of\nthe event loop.  If the function already calls its callback on a next tick,\nno extra deferral is added. This is useful for preventing stack overflows\n(`RangeError: Maximum call stack size exceeded`) and generally keeping\n[Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\ncontained.\n\n\n### Example\n```javascript\nsignature as the function passed in.\n\nfunction sometimesAsync(arg, callback) {\n    if (cache[arg]) {\n        return callback(null, cache[arg]); // this would be synchronous!!\n    } else {\n        doSomeIO(arg, callback); // this IO would be asynchronous\n    }\n}\n\n// this has a risk of stack overflows if many results are cached in a row\nasync.mapSeries(args, sometimesAsync, done);\n\n// this will defer sometimesAsync's callback if necessary,\n// preventing stack overflows\nasync.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n\n```\n\n","context":[]}],"hasConstructorInfo":false,"breadcrumbs":[{"path":[["/","async"]],"name":"async","delimiter":"/"},{"path":[["/","async"],["/","Utils"]],"name":"Utils","delimiter":"/"},{"path":[["/","async"],["/","Utils"],[".","ensureAsync"]],"name":"ensureAsync","delimiter":"."}],"sourceFile":"dist\\async.js","sourceLine":3195,"sourceModule":{"path":[["/","async"]],"pathstr":"async"},"sanitaryName":"ensureasync","baseTagPath":"../../../../../../"}
