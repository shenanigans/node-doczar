
/**     @module/class doczar.ComponentCache
    Roots a tree of [Component](doczar.Component) instances and centralizations the document
    creation and output process.
@Object #root
    Stores the global namespace in subproperty `property`.
@Array[Object] #warnings
    All the warning messages generated by Components in this cache so far, as JSON documents.
    ```javascript
    {
        ctype:      'property',
        valtype:    [ '.Array' ],
        path:       '.doczar.Component#warnings',
        warning:    'descriptive warning message'
    }
    ```
*/

var path = require ('path');
var async = require ('async');
var mkdirp = require ('mkdirp');
var fs = require ('fs-extra');
var Component = require ('./Component');
var Patterns = require ('./Patterns');
var Templates = require ('./Templates');

var concatArrs = function(){
    var out = [];
    for (var i in arguments)
        out.push.apply (out, arguments[i]);
    return out;
};
var isArr = function (a) {
    if (!a) return false;
    return a.__proto__ === Array.prototype;
};

var ComponentCache = function(){
    this.root = { property:{} };
    this.warnings = [];
};

/**     @member/Function getComponent
    Find or create a [Component](doczar.Component) for a given path. This is the only official way
    to create a Component.
@argument/Array[Array] tpath
    An Array path for the desired Component, as `[ [ ".", "Foo" ], [ "#", "Bar" ], ...]`.
@returns/doczar.Component
*/
ComponentCache.prototype.getComponent = function (tpath) {
    var pointer = this.root;
    for (var i in tpath) {
        var step = tpath[i];
        var fragCType = Patterns.delimiters[step[0]];
        var location = pointer[fragCType];
        if (!location) {
            console.log (tpath, step);
        }
        var fragName = step[1] || '';
        try {
            if (isArr (location))
                if (step[1] && Object.hasOwnProperty.call (pointer[fragCType+'ByName'], step[1]))
                    pointer = pointer[fragCType+'ByName'][step[1]];
                else {
                    var newComponent = new Component (
                        this,
                        tpath.slice (0, i+1),
                        pointer !== this.root ? pointer : undefined
                    );
                    location.push (newComponent);
                    if (fragName)
                        pointer[fragCType+'ByName'][fragName] = newComponent;
                    else {
                        var unname = newComponent.path[newComponent.path.length-1][1];
                        pointer[fragCType+'ByName'][unname] = newComponent;
                    }
                    pointer = newComponent;
                }
            else if (Object.hasOwnProperty.call (location, fragName))
                pointer = location[fragName];
            else
                pointer = location[fragName] = new Component (
                    this,
                    tpath.slice (0, i+1),
                    pointer !== this.root ? pointer : undefined
                );
        } catch (err) {
            console.log (err.stack);
            var uglypath = '';
            for (var i in tpath)
                uglypath += (tpath[i][0]||'.') + tpath[i][1];
            throw new Error ('invalid path '+uglypath);
        }
    }

    return pointer;
};

/**     @member/Function resolve

@argument/Array[Array] tpath
    An Array path for the desired Component, as `[ [ ".", "Foo" ], ["#", "Bar"], ...]`.
@returns/doczar.Component
@throws/Error missing
    If the Component is not found, an Error is thrown.
*/
ComponentCache.prototype.resolve = function (tpath) {
    if (!tpath || !tpath.length)
        throw new Error ('invalid path');

    var rootName = tpath[0][1];
    var pointer;
    if (Object.hasOwnProperty.call (this.root.property, rootName)) // naturally rooted
        pointer = this.root;
    else
        throw new Error ('not found');

    for (var i in tpath) {
        var step = tpath[i];
        var stepCType = Patterns.delimiters[step[0]||'.'];
        var location = pointer[stepCType];
        var fragName = step[1] || '';
        if (isArr (location))
            if (step[1] && Object.hasOwnProperty.call (pointer[stepCType+'ByName'], step[1]))
                pointer = pointer[stepCType+'ByName'][step[1]];
            else
                throw new Error ('not found');
        else if (Object.hasOwnProperty.call (location, fragName))
            pointer = location[fragName];
        else
            throw new Error ('not found');
    }
    return pointer;
};

/**     @member/Function submit

*/
ComponentCache.prototype.submit = function (tpath, info) {
    var pointer = this.getComponent (tpath);
    pointer.submit (info);
    return pointer;
};

/**     @member/Function finalize
    Prepare every [Component](doczar.Component) in the cache for rendering and execute a callback.
@argument/Object options
@callback
    @argument/Array[Object] warnings
        Warning messages produced by this specific `Component` during finalization, as JSON documents.
        ```javascript
        {
            ctype:      'property',
            valtype:    [ '.Array' ],
            path:       '.doczar.Component#warnings',
            warning:    'descriptive warning message'
        }
        ```
*/
ComponentCache.prototype.finalize = function (options, callback) {
    var self = this;
    async.each (Object.keys (this.root.property), function (propname, callback) {
        self.root.property[propname].finalize (self.warnings, options, callback);
    }, function(){
        callback (self.warnings);
    });
};

/**     @member/Function writeFiles

*/
ComponentCache.prototype.writeFiles = function (basedir, options, callback) {
    var self = this;
    var rootdir = path.join (basedir, 'property');
    mkdirp (rootdir, function (err) {
        if (err) return callback (err);

        var indexSourcePath = path.join (
            path.resolve (path.dirname (module.filename), '../'),
            'indexFiles'
        );
        async.each ([
            'index.css',
            'index.js',
            'unknown.html',
        ], function (fnameToCopy, callback) {
            fs.copy (
                path.join (indexSourcePath, fnameToCopy),
                path.join (basedir, fnameToCopy),
                callback
            );
        }, function (err) {
            if (err)
                return callback (err);

            var rootPage = Templates.renderRoot (self.root, self, options);
            fs.writeFile (path.join (basedir, 'index.html'), rootPage, function (err) {
                if (err)
                    return callback (err);

                fs.copy (
                    path.join (
                        path.resolve (path.dirname (module.filename), '../'),
                        'node_modules',
                        'highlight.js',
                        'styles',
                        options.codeStyle + '.css'
                    ),
                    path.join (basedir, 'highlight.css'),
                    function (err) {
                        if (err)
                            return callback (err);
                        basedir = rootdir;
                        async.each (Object.keys (self.root.property), function (propname, callback) {
                            var prop = self.root.property[propname];
                            if (
                                ( options.showAPI && prop.isApi)
                             || ( !options.showAPI && ( !prop.isDevelopment || options.showDev ) )
                            )
                                self.root.property[propname].writeFiles (
                                    path.join (rootdir, propname),
                                    '../../',
                                    options,
                                    self.warnings,
                                    callback
                                );
                            else return callback();
                        }, callback);
                    }
                );
            });
        });
    });
};

/**     @member/Function getRelativeURLForType
    Attempt to produce a relative url to link from one Component's root output page to another.
@argument/Array[Array] start
    The current Component whose root page is requesting this href.
@argument/Array[Array] type
    The Component to which the root page needs to link.
@returns/String
    Either a relative url to the requested Component's root page, or `"javascript:return false;"`.
*/
ComponentCache.prototype.getRelativeURLForType = function (start, type) {
    if (!type || !type.length) return 'javascript:return false;';
    var sameFromRoot = 0;
    try {
        for (var i in start)
            if (
                type[i]
             && start[i][1] == type[i][1]
             && (
                    !start[i][0]
                 || !type[i][0]
                 || start[i][0] == type[i][0]
                )
            )
                sameFromRoot++;
            else
                break;
    } catch (err) {
        return 'javascript:return false;';
    }

    // advance a pointer to ensure existence of the type
    var str = '';
    var pointer = this.root;
    for (var i=0; i<sameFromRoot; i++) {
        try {
            var location = pointer[Patterns.delimiters[type[i][0]||'.']];
            if (isArr (location))
                location = pointer[Patterns.delimiters[type[i][0]||'.']+'ByName'];
            pointer = location[type[i][1]];
            if (!pointer) throw 'not found';
        } catch (err) {
            // not found!
            return 'javascript:return false;';
        }
    }

    // create a ../../ navback
    for (var i=0, j=start.length-sameFromRoot; i<j; i++)
        str += '../../';

    for (var i=sameFromRoot, j=type.length; i<j; i++) {
        try {
            var location = pointer[Patterns.delimiters[type[i][0]||'.']];
            if (isArr (location))
                location = pointer[Patterns.delimiters[type[i][0]||'.']+'ByName'];
            pointer = location[type[i][1]];
            if (!pointer) throw 'not found';
        } catch (err) {
            // not found!
            return 'javascript:return false;';
        }
        var frag = type[i];
        str += Patterns.delimiters[frag[0]||'.'] + '/';
        if (frag[1])
            str += frag[1] + '/';
    }
    return str + 'index.html';
};

module.exports = ComponentCache;
