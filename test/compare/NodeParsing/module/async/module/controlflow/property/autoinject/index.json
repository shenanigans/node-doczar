{"elemID":"component_224","date":"6/5/2020","time":"12:00am","name":"autoInject","pathname":"autoInject","pathstr":"async/ControlFlow.autoInject","path":[["/","async"],["/","ControlFlow"],[".","autoInject"]],"flags":[],"source":[["/","async"],["/","ControlFlow"]],"sourcestr":"async/ControlFlow","superClasses":[],"interfaces":[],"satisfies":[],"ctype":"property","valtype":[{"path":[[null,"Function"]],"isPointer":false,"isArray":false,"generics":[],"name":"Function","explicit":false},{"path":[[null,"Function"]],"isPointer":false,"isArray":false,"generics":[],"name":"Function","explicit":false}],"isKwarg":false,"isMultiArg":false,"isSpare":false,"isModule":false,"isClass":false,"simpleCtype":"property","hideCtype":true,"spares":[],"modules":[],"enums":[],"statics":[],"functions":[],"members":[],"methods":[],"localValues":[],"localFunctions":[],"arguments":[{"elemID":"component_220","date":"6/5/2020","time":"12:00am","name":"tasks","pathname":"tasks","pathstr":"async/ControlFlow.autoInject(0","path":[["/","async"],["/","ControlFlow"],[".","autoInject"],["(","tasks"]],"flags":[],"source":[["/","async"],["/","ControlFlow"],[".","autoInject"]],"sourcestr":"async/ControlFlow.autoInject","superClasses":[],"interfaces":[],"satisfies":[],"ctype":"argument","valtype":[],"isKwarg":false,"isMultiArg":false,"isSpare":false,"isModule":false,"isClass":false,"simpleCtype":"argument","hideCtype":true,"spares":[],"modules":[],"enums":[],"statics":[],"functions":[],"members":[],"methods":[],"localValues":[],"localFunctions":[],"arguments":[],"finalArgs":[],"finalKwargs":[],"returns":[],"throws":[],"names":[],"events":[],"signatures":[],"propertySymbols":[],"memberSymbols":[],"returnsSymbols":[],"hasChildren":false,"isTotallyEmpty":true,"hasConstructorInfo":false,"isFunction":false,"breadcrumbs":[{"path":[["/","async"]],"name":"async","delimiter":"/"},{"path":[["/","async"],["/","ControlFlow"]],"name":"ControlFlow","delimiter":"/"},{"path":[["/","async"],["/","ControlFlow"],[".","autoInject"]],"name":"autoInject","delimiter":"."},{"path":[["/","async"],["/","ControlFlow"],[".","autoInject"],["(","tasks"]],"name":"tasks","delimiter":"("}],"sanitaryName":"tasks"},{"elemID":"component_221","date":"6/5/2020","time":"12:00am","name":"callback","pathname":"callback","pathstr":"async/ControlFlow.autoInject(1","path":[["/","async"],["/","ControlFlow"],[".","autoInject"],["(","callback"]],"flags":[],"source":[["/","async"],["/","ControlFlow"],[".","autoInject"]],"sourcestr":"async/ControlFlow.autoInject","superClasses":[],"interfaces":[],"satisfies":[],"ctype":"argument","valtype":[],"isKwarg":false,"isMultiArg":false,"isSpare":false,"isModule":false,"isClass":false,"simpleCtype":"argument","hideCtype":true,"spares":[],"modules":[],"enums":[],"statics":[],"functions":[],"members":[],"methods":[],"localValues":[],"localFunctions":[],"arguments":[],"finalArgs":[],"finalKwargs":[],"returns":[],"throws":[],"names":[],"events":[],"signatures":[],"propertySymbols":[],"memberSymbols":[],"returnsSymbols":[],"hasChildren":false,"isTotallyEmpty":true,"hasConstructorInfo":false,"isFunction":false,"breadcrumbs":[{"path":[["/","async"]],"name":"async","delimiter":"/"},{"path":[["/","async"],["/","ControlFlow"]],"name":"ControlFlow","delimiter":"/"},{"path":[["/","async"],["/","ControlFlow"],[".","autoInject"]],"name":"autoInject","delimiter":"."},{"path":[["/","async"],["/","ControlFlow"],[".","autoInject"],["(","callback"]],"name":"callback","delimiter":"("}],"sanitaryName":"callback"}],"finalArgs":[],"finalKwargs":[],"returns":[],"throws":[],"names":[],"events":[],"signatures":[],"propertySymbols":[],"memberSymbols":[],"returnsSymbols":[],"hasChildren":true,"isTotallyEmpty":false,"sourceFile":"dist\\async.js","sourceLine":2062,"summaryDoc":[{"doc":"\n\nA dependency-injected version of the [async.auto](async/ControlFlow.auto) function. Dependent\ntasks are specified as parameters to the function, after the usual callback\nparameter, with the parameter names matching the names of the tasks it\ndepends on. This can provide even more readable task graphs which can be\neasier to maintain.\n\nIf a final callback is specified, the task results are similarly injected,\nspecified as named parameters after the initial error parameter.\n\nThe autoInject function is purely syntactic sugar and its semantics are\notherwise equivalent to [async.auto](async/ControlFlow.auto).\n\n\n### Example\n```javascript\nthe tasks have been completed. It receives the `err` argument if any `tasks`\npass an error to their callback, and a `results` object with any completed\ntask results, similar to `auto`.\n\n//  The example from `auto` can be rewritten as follows:\nasync.autoInject({\n    get_data: function(callback) {\n        // async code to get some data\n        callback(null, 'data', 'converted to array');\n    },\n    make_folder: function(callback) {\n        // async code to create a directory to store a file in\n        // this is run at the same time as getting the data\n        callback(null, 'folder');\n    },\n    write_file: function(get_data, make_folder, callback) {\n        // once there is some data and the directory exists,\n        // write the data to a file in the directory\n        callback(null, 'filename');\n    },\n    email_link: function(write_file, callback) {\n        // once the file is written let's email a link to it...\n        // write_file contains the filename returned by write_file.\n        callback(null, {'file':write_file, 'email':'user@example.com'});\n    }\n}, function(err, results) {\n    console.log('err = ', err);\n    console.log('email_link = ', results.email_link);\n});\n\n// If you are using a JS minifier that mangles parameter names, `autoInject`\n// will not work with plain functions, since the parameter names will be\n// collapsed to a single letter identifier.  To work around this, you can\n// explicitly specify the names of the parameters your task function needs\n// in an array, similar to Angular.js dependency injection.\n\n// This still has an advantage over plain `auto`, since the results a task\n// depends on are still spread into arguments.\nasync.autoInject({\n    //...\n    write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n        callback(null, 'filename');\n    }],\n    email_link: ['write_file', function(write_file, callback) {\n        callback(null, {'file':write_file, 'email':'user@example.com'});\n    }]\n    //...\n}, function(err, results) {\n    console.log('err = ', err);\n    console.log('email_link = ', results.email_link);\n});\n\n```\n\n","context":[]}],"details":[{"doc":"\n\nA dependency-injected version of the [async.auto](async/ControlFlow.auto) function. Dependent\ntasks are specified as parameters to the function, after the usual callback\nparameter, with the parameter names matching the names of the tasks it\ndepends on. This can provide even more readable task graphs which can be\neasier to maintain.\n\nIf a final callback is specified, the task results are similarly injected,\nspecified as named parameters after the initial error parameter.\n\nThe autoInject function is purely syntactic sugar and its semantics are\notherwise equivalent to [async.auto](async/ControlFlow.auto).\n\n\n### Example\n```javascript\nthe tasks have been completed. It receives the `err` argument if any `tasks`\npass an error to their callback, and a `results` object with any completed\ntask results, similar to `auto`.\n\n//  The example from `auto` can be rewritten as follows:\nasync.autoInject({\n    get_data: function(callback) {\n        // async code to get some data\n        callback(null, 'data', 'converted to array');\n    },\n    make_folder: function(callback) {\n        // async code to create a directory to store a file in\n        // this is run at the same time as getting the data\n        callback(null, 'folder');\n    },\n    write_file: function(get_data, make_folder, callback) {\n        // once there is some data and the directory exists,\n        // write the data to a file in the directory\n        callback(null, 'filename');\n    },\n    email_link: function(write_file, callback) {\n        // once the file is written let's email a link to it...\n        // write_file contains the filename returned by write_file.\n        callback(null, {'file':write_file, 'email':'user@example.com'});\n    }\n}, function(err, results) {\n    console.log('err = ', err);\n    console.log('email_link = ', results.email_link);\n});\n\n// If you are using a JS minifier that mangles parameter names, `autoInject`\n// will not work with plain functions, since the parameter names will be\n// collapsed to a single letter identifier.  To work around this, you can\n// explicitly specify the names of the parameters your task function needs\n// in an array, similar to Angular.js dependency injection.\n\n// This still has an advantage over plain `auto`, since the results a task\n// depends on are still spread into arguments.\nasync.autoInject({\n    //...\n    write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n        callback(null, 'filename');\n    }],\n    email_link: ['write_file', function(write_file, callback) {\n        callback(null, {'file':write_file, 'email':'user@example.com'});\n    }]\n    //...\n}, function(err, results) {\n    console.log('err = ', err);\n    console.log('email_link = ', results.email_link);\n});\n\n```\n\n","context":[]}],"isFunction":true,"hasConstructorInfo":false,"breadcrumbs":[{"path":[["/","async"]],"name":"async","delimiter":"/"},{"path":[["/","async"],["/","ControlFlow"]],"name":"ControlFlow","delimiter":"/"},{"path":[["/","async"],["/","ControlFlow"],[".","autoInject"]],"name":"autoInject","delimiter":"."}],"aliasTo":{"path":[["/","async"],["/","ControlFlow"],[".","autoInject"]],"pathstr":"async/ControlFlow.autoInject"},"sanitaryName":"autoinject","baseTagPath":"../../../../../../"}
